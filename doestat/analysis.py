# Copyright (C) 2025 Romulo Pires
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import pandas as pd
import numpy as np
from scipy.stats import norm, t, f, gaussian_kde #library for regression
import matplotlib.pyplot as plt
import plotly.graph_objs as go
import seaborn as sns #library for analysis
from IPython.display import display, HTML
from .auxvalues import Auxvalues

        
class Analysis: 
    
    """
    Class -> Analysis(X, y)
    
    A class designed for evaluating factorial planning effects, offering insights into the contributions 
    of individual factors and their interactions in experimental designs.
    
    Features:
    ---------
    - Factorial Effect Analysis: Calculates and visualizes the effects of factors in a factorial design.
    - Probability Graph: Displays the distribution of effects using a Gaussian-based probability plot.
    - Percentage Contributions: Quantifies the relative contributions of each effect to the overall variability.
    - Error Handling: Supports effect error calculation and confidence intervals using the t-Student distribution.
    
    Parameters:
    -----------
    X  : matrix
        A matrix representing the factors (effects/interactions) to be analyzed.
    y  : array-like
        A vector or matrix containing the response variable(s).
    yc : array-like, optional (default=None)
        A vector of central points.
    type_matrix : str, optional (default=None)
        Specifies if the design includes interactions to be calculated.
        - "interaction"
    effect_error : str, optional (default=None)
        Specifies the type of effect error to be considered:
        - "cp" -> "Central Points"
        - "replica" -> "Replica"
   
    Attributes:
    -----------
    matrix_x : array-like
        The selected or calculated factorial design matrix.
    vector_y : array-like
        The response vector provided during instantiation, or the mean of replicates.
    error : float
        The calculated effect error
    
    Methods:
    --------
    1. effect_analysis:
        Generates and displays:
        - A probability graph to visualize the Gaussian distribution of effects.
        - A bar plot illustrating the percentage contributions of effects.
        Saves the generated plots as an image file.
        Usage: `doe.Analysis(X, y).effect_analysis()`
    
    Notes:
    ------
    - This class is suitable for factorial designs and provides visual and numerical tools for interpreting experimental results.
    - Input data should be formatted appropriately:
      - `X` should represent the coded matrix of factors. Interactions can be calculated within this class.
      - `y` should be the corresponding response vector or matrix.
    - The Effect Error and t-Student values are calculated within the class to enable confidence interval estimation, improving the robustness of the analysis.
    - Graphs generated by this class are inspired by the factorial effect routines in Octave and adapted for Python.
    
    """

    def __init__(self, x, y, yc=[], type_matrix=None, order=None, effect_error=None):
        self.aux = Auxvalues()
        self.type_matrix = type_matrix
        self.effect_error = effect_error
        self.order = order
        self.X = self.aux.amatrix(x, type_matrix=self.type_matrix, order=self.order)
        self.y_array, self.y, self.exp_error, self.eff_error, self.t = self.aux.avector(x, y, yc, effect_error=self.effect_error)
        
    @property
    def error(self):
        """
        Returns the calculated error effect
        """
        return self.eff_error
                
    @property 
    def matrix_x(self): 
        """
        Returns the design matrix (X) including factors and interactions.
        
        This matrix represents the selected experimental design 
        and is used for effect calculations and analysis.
        """
        return self.X
    
    @property 
    def vector_y(self): 
        """
        Returns the response vector (y).
    
        This array contains the calculated responses used in the analysis.
        """
        return self.y

    @property
    def __effect(self):  # Returns product values between effects and response
        return (self.X.T * self.y).T # Multiply the transposed matrix by the response vector, then transpose the result back

    @property
    def __n_effect(self):  # Returns dimensions of the matrix with effects (coded_value * response)
        return self.X.shape

    @property
    def __effect_indices(self):  # Returns list with respective interactions
        return self.X.T.index

    @property
    def __generate_start_center_end_gauss(self):  # Returns the values of the Gaussian
        start = [0]
        center = []
        end = []
        gauss = []
        for i in range(self.__n_effect[1]):
            end.append(start[i] + (1 / self.__n_effect[1]))
            start.append(end[i])
            center.append((start[i] + end[i]) / 2)
            gauss.append(norm.ppf(center))
        return gauss

    @property
    def __define_gaussian(self):  # Returns the values of the Gaussian
        return self.__generate_start_center_end_gauss[self.__n_effect[1] - 1]
        
    @property
    def __calculate_effects(self):  # Returns vector with effects
        effects = (np.einsum('ij->j', self.__effect)) / (self.__n_effect[0] / 2) # np.einsum -> function that sums columns of a matrix
        if effects.size == 0 or np.all(np.isnan(effects)):
            return "Check if the Matrix or Vector was selected correctly"
        return effects

    @property
    def __calculate_percentage_effects(self):  # Returns vector with probability
        return (self.__calculate_effects ** 2 / np.sum(self.__calculate_effects ** 2)) * 100

    @property
    def __sort_effects_probabilities(self):  # Returns dataframe sorted in ascending order with effect values
        data = pd.DataFrame({'Effects': self.__calculate_effects}, index=self.__effect_indices)
        data = data.sort_values('Effects', ascending=True)
        return data

    @property
    def __define_ci(self):  # Returns set of Confidence Interval points
        return np.full(len(self.__define_gaussian), self.eff_error * self.t)

    @property
    def __probability_effect(self):
        plt.figure(figsize=(10, 6))
        # Confidence Interval
        plt.plot(-1 * self.__define_ci, self.__define_gaussian, color='red') # Left
        plt.plot(0 * self.__define_ci, self.__define_gaussian, color='blue') # Center
        plt.plot(self.__define_ci, self.__define_gaussian, color='red')      # Right
        # Scatter plot
        plt.scatter(self.__sort_effects_probabilities['Effects'], self.__define_gaussian, s=25, color='darkred')
        #plt.title('Probability Effects Plot', fontsize=12, fontweight='black', loc='center')
        plt.ylabel('z')
        plt.xlabel('Effects')
        plt.grid(True)
        # Mark points
        for i, label in enumerate(self.__sort_effects_probabilities.index):
            plt.annotate(label, (self.__sort_effects_probabilities['Effects'].values[i],
                                    self.__define_gaussian[i]),
                                    textcoords="offset points",  
                                    xytext=(10, 0),  
                                    ha='left',  
                                    fontsize=9, 
                                    color='black'
                           )

        plt.tight_layout()
        plt.savefig('Probability Effects Plot.png',transparent=True) 
        plt.show()

    @property
    def __percentage_effect(self):
        plt.figure(figsize=(10, 6))
        plt.grid(True)
        sns.barplot(
            x='%', 
            y='Effects', 
            data=pd.DataFrame({
                'Effects': self.__effect_indices, 
                '%': self.__calculate_percentage_effects  
            }).sort_values(by = '%', ascending=False),
            color='purple',
            orient='h'
        )
        plt.axvline(x=5, color='red', linewidth=1, linestyle='--')
        plt.tight_layout()
        plt.savefig('Percentage Effects Plot.png',transparent=True) 
        plt.show()
        
    def effect_analysis(self, exclude_variables=None):
        """
        Analyzes the effect of factors and optionally excludes specified variables from the analysis.

        Parameters:
        exclude_variables (list of str, optional): 
            A list of variable names to exclude from the analysis. 
            If provided, the method recalculates the probability and percentage effects 
            after removing the specified variables.
    
        Example:
        .effect_analysis(exclude_variables=['A', 'B']) 
            Recalculates the probability and percentage effects excluding variables 'A' and 'B'.
        """
        # Check the variables in matrix X
        if exclude_variables:
            valid_variables = [var for var in exclude_variables if var in self.X.columns]
            invalid_variables = [var for var in exclude_variables if var not in self.X.columns]
            
            if not valid_variables:
                raise ValueError("None of the variables to exclude were found in the matrix.")     
            
            if invalid_variables:
                raise ValueError(f"The following variables were not found in the matrix: {', '.join(invalid_variables)}")
            
            # Remove the variables for new analysis
            self.X = self.X.drop(columns=valid_variables)
            display(HTML("<div style='text-align: left; font-weight: bold; font-size: 12px;'>Factors excluded</div>"))
            print(valid_variables)
            print('\n')
            
        # Display the variables used    
        display(HTML("<div style='text-align: left; font-weight: bold; font-size: 12px;'>Factors used</div>"))
        print(list(self.X.columns))
        
        # Display the Probability Effects Plot
        display(HTML("<div style='text-align: center; font-weight: bold; font-size: 18px;'>Probability Effects Plot</div>"))
        self.__probability_effect
        print('\n')
        
        # Display the Percentage Effects Plot
        display(HTML("<div style='text-align: center; font-weight: bold; font-size: 18px;'>Percentage Effects Plot</div>"))
        self.__percentage_effect
